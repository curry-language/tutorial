\chapter{Design Patterns}

\section{Overview}

A \emph{design pattern}\index{design pattern}
is a proven solution to a recurring
problem in software design and development.
A typical pattern is not reusable code, as a library function would be,
but consists of problems, motivations, and design decisions
related to the elements of a software artifact.
Many functional logic design patterns are centered on the characteristic
features of the paradigm, non-determinism and logic variables.

Patterns originated for object-oriented programming languages
and became an important disciple in computer
science after \cite{GammaEtAl94}.
Design patterns for functional logic programming
were introduced and further developed in
\cite{AntoyHanus02FLOPS,AntoyHanus11WFLP}.
We present a pattern using \emph{tags}\index{pattern!tag},
typically a one-line description of some key element
of a problem or its solution.
In this tutorial, we use only four simple tags:
\emph{name}\index{pattern!name},
\emph{intent}\index{pattern!intent},
\emph{solution}\index{pattern!solution}, and
\emph{structure}\index{pattern!structure}
with self-explaining meaning.

\subsection{Deep selection}\label{sec-Deep-selection}

\begin{center}
\begin{tabular}{@{} | *{2}{@{\hspace{3pt}} l @{\hspace{3pt}} |} @{}}
\hline
Name & \emph{Deep selection} \\
\hline 
Intent & pattern matching at arbitrary depth in recursive types \\
\hline
Applicability & select an element with given properties in a structure \\
\hline
Structure & combine a type generator with a functional pattern \\
\hline
\end{tabular}
\end{center}

\noindent
Recursively defined
types, such as lists and trees, have components at arbitrary
depths that cannot be selected by pattern matching because pattern
matching selects components only at predetermined positions.  
For recursively defined types, the
selection of some element with a given property in a
data structure typically requires code for the traversal of the
structure which is intertwined with the code for using the element.  The
combination of functional patterns with type generators
allows us to select elements arbitrarily nested in a
structure in a pattern matching-like fashion without
explicit traversal of the structure and mingling of
different functionalities of a problem.

We show the application of this pattern in one example.
Consider a simple type for representing arithmetic
expressions:
%
\begin{prog}
data Exp = Lit Int
         | Var [Char]
         | Add Exp Exp
         | Mul Exp Exp
\end{prog}
%
For example, the expression $x+1$ is encoded as 
$e = \code{Add (Var "x") (Lit 1)}$.
Suppose that we want to match an expression with 
some property, e.g., the expression is a variable,
regardless of whether it occurs.
First, we define a function, \emph{withSub},
that takes an expression $t$
and non-deterministically generates 
some expression with $t$ as subexpression.
%
\begin{prog}
withSub exp = exp
            ? op (withSub exp) unknown
            ? op unknown (withSub exp)
   where op = Add ? Mul  
\end{prog}
%
For example, if $t = \code{Var "x"}$, then
\code{withSub $t$} evaluates, among other possibilities,
to an expression matching the expression $e$ discussed earlier.
Thus, using functional patterns, Sect.~\ref{Functional Patterns},
we can pattern match a subexpression $t$ anywhere in an expression $e$.

To see this in action, consider the function \emph{varOf} defined below.
This function takes an expression $e$ and returns  the identifier
of a variable occurring anywhere in $e$.  With ordinary pattern matching,
only a variable at a fixed position, e.g., the root or the left
argument of an expression, can be matched.  With \emph{withSub} we
match any variable anywhere:
%
\begin{prog}
varOf :: Exp -> String
varOf (withSub (Var v)) = v  
\end{prog}
%
For example, the set of the identifiers of all the variables of
occurring in an expression $e$ is simply obtained with the set function
of \code{varOf}, i.e., \code{\funset{varOf} $e$}.


\subsection{Constrained Constructor}\label{sec-constrained-constructor}

\begin{center}
\begin{tabular}{@{} | *{2}{@{\hspace{3pt}} l @{\hspace{3pt}} |} @{}}
\hline
Name & \emph{Constrained Constructor} \\
\hline 
Intent & prevent invoking a constructor that might create invalid data \\
\hline
Applicability & a type is too general for a problem \\
\hline
Structure & define a function that either invokes a constructor or fails \\
\hline
\end{tabular}
\end{center}
%
The signature of a functional logic program is partitioned into
\emph{defined operations} and \emph{data constructors}.
They differ in that operations manipulate data by means of rewrite rules,
whereas constructors create data and have no associated rewrite rules.
Therefore, a constructor symbol cannot perform any checks on the
arguments to which it is applied.  If a constructor is invoked
with arguments of the correct types, but inappropriate values,
conceptually invalid data is created.
We use an example to clarify this point.

The \emph{Missionaries and Cannibals} puzzle is stated as follows.
Three missionaries and three cannibals want to cross a river
with a boat that holds up to two people.
Furthermore, the missionaries, if any, on either bank of the river
cannot be outnumbered by the cannibals
(otherwise, as the intuition hints, they would be eaten by the cannibals).

A state of this puzzle is represented by the number of
missionaries and cannibals and the presence of the boat on an
arbitrarily chosen bank of the river, by convention the \emph{initial} one:
%
\begin{prog}
data State = State Int Int Bool
\end{prog}
%
For example, with suitable conventions,
\code{(State 3 3 True)} represents the initial state.
The simplicity of this representation has the drawback
that invalid states, e.g., those with more than 6 people,
can be created as well.
Unless complex and possibly inefficient types for the state are
defined, it is not possible to avoid the creation of invalid states
using constructors alone.

The \emph{Constrained Constructor} pattern avoids
the creation of invalid states.
The programmer invokes the constructor indirectly
through the following function:
%
\begin{prog}
makeState m c b | valid \boolAnd safe = State m c b
   where valid = 0<=m \boolAnd m<=3 \boolAnd 0<=c \boolAnd c<=3
         safe  = m==3 || m==0 || m==c
\end{prog}
%
Function \code{makeState} invokes the constructor only
after checking that only states
that are consistent with the physical conditions of the
puzzle and are safe for the missionaries will be created.
For example, 
\code{(State 2 1 \panon)} is not safe since on one bank of the river
the cannibals outnumber the missionaries
and therefore should not be created.
In fact, the call \code{makeState\,2\,1\,\_} fails because
the rule's condition is not satisfied.
In a suitable non-deterministic program, this failure can be
simply and silently ignored.

Operation \code{makeState} eases the definition of an operation,
say \code{move}, to move people and boat across the river:
%
\begin{prog}
move (State m c True)
   = makeState (m-2) c False      \lineComment move 2 missionaries
   ? makeState (m-1) c False      \lineComment move 1 missionary
   ? makeState m (c-2) False      \lineComment move 2 cannibals
   ? ...
\end{prog}
%
since ``undesirable'' states are never produced
\proghref{missionaries}{Program}.
